//МЕТОД простых итераций (МПИ)
//Матрица переменных
A=[5.526 0.305 0.887 0.037 ; 0.658 2.453 0.678 0.192;
0.398 0.232 4.957 0.567 ; 0.081 0.521 0.192 4.988];
//вектор свободных членов
b=[0.774;0.245;0.343;0.263];
clc;//чистим экран
disp("Solution begins");
disp("System:");
[A b]//исходные данные системы
[M,N]=size(A);//размер матрицы
//погрешность членов системы – это погрешность, с которой значения
//матрицы А и вектора b определены
eps0=0.001;
//допустимая погрешность решения – это погрешность, с которой мы
//хотим вычислить решение
eps1=0.01;
//определим число обусловленности
mu=cond(A);
printf("Condition number %f\n",mu);
//вычислим нормы матрицы и вектора свободных членов
normA=norm(A,'fro');
normB=norm(b,'fro');
/////////////------------------------
/////////////ОПРЕДЕЛЕНИЕ ПОГРЕШНОСТИ РЕШЕНИЯ
/////////////------------------------

Delta = norm(inv(A),1) * eps0;
printf("Absolut error: %f\n",Delta);
if(Delta <= eps1)
 printf("couldn`t be solved within eps=%f\n",eps1);
end;
delta1= norm(inv(A),1)*norm(A,1)* eps0;
//определим полную относительную погрешность получаемого решения
//при учете погрешности измерений eps0 матрицы А и вектора b
delta2=norm(inv(A),1)*(norm(eps0*A, 1)/norm(A,1) + norm(eps0*b,1)/norm(b,1))/(1 - norm(inv(A),1)*norm(eps0*A,1)/norm(A,1));
printf("Solution error\n absolute: %f,\n relative: %f\n",Delta,delta2);
/////////////------------------------
/////////////РЕШЕНИЕ СИМТЕМЫ МЕТОДОМ ПРОСТОЙ ИТЕРАЦИИ
/////////////------------------------
//приводим систему к виду, удобному для метода
E=eye(A);//единичная матрица размера А
// diag(A) матрица с элементами на главной диагонали (остальные –
//нули):
Diag=diag(A);
B = zeros(M,1);
for i=1:M
  CC(i,:)=  A(i,:) / A(i,i);
  B(i) = b(i) / A(i,i); 
end;
C=(E-CC);//новая матрица для расчетов
//выясняем условия сходимости итерационного процесса
//по достаточному условию сходимости через норму матрицы МПИ С
normC=norm(C,'fro');
printf("Matrix norm is: %f\n",normC);
if (norm(C,1)<1)
 printf("could be solved using iteration method");
end;
//задаем начальное приближение решения нулевым вектором
X=zeros(N,1);
normBB=norm(B,'fro');
//определяем необходимое число шагов для метода
k = log(eps0)* log(1 - norm(C,1)) / log(norm(B,1)) / log(norm(C,1))
printf("Steps to do: %1.0f\n",k);//округляем до верхнего целого
//основной цикл метода
for i=1:(k+1)
 XK=X;//запоминаем предыдущее решение
 disp(i);//выводим текущий шаг
 disp("C*X", C*X)
 disp("B", B)
 X=C*X+B //выводим текущее решение
 disp(C*X+B)
 delta=norm(XK-X,'fro');//разность между шагами
end;
deltaX = norm(C,1)^(k+1) * norm(X, 1) / (1 - norm(C,1));
printf("Solution error is %f\n ",deltaX);
